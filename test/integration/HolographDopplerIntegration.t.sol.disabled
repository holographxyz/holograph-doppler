// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../../src/HolographFactory.sol";
import "../../src/FeeRouter.sol";
import "../../src/StakingRewards.sol";
import "../mock/MockLZEndpoint.sol";
import "../mock/MockWETH.sol";
import "../mock/MockHLG.sol";
import "../mock/MockSwapRouter.sol";
import "../mock/MockAirlock.sol";
import "../mock/MockERC20.sol";
import "../mock/MockTokenFactory.sol";
import "../mock/MockGovernanceFactory.sol";
import "../mock/MockPoolInitializer.sol";
import "../mock/MockLiquidityMigrator.sol";
import {CreateParams} from "lib/doppler/src/Airlock.sol";
import {ITokenFactory} from "../../lib/doppler/src/interfaces/ITokenFactory.sol";
import {IGovernanceFactory} from "../../lib/doppler/src/interfaces/IGovernanceFactory.sol";
import {IPoolInitializer} from "../../lib/doppler/src/interfaces/IPoolInitializer.sol";
import {ILiquidityMigrator} from "../../lib/doppler/src/interfaces/ILiquidityMigrator.sol";

/**
 * @title Holograph-Doppler Integration Test
 * @notice End-to-end test of the complete fee integration flow
 * @dev Tests the full journey: Launch → Fee Collection → Bridging → Swap → Distribution
 */
contract HolographDopplerIntegrationTest is Test {
    /* -------------------------------------------------------------------------- */
    /*                               Test Contracts                               */
    /* -------------------------------------------------------------------------- */

    HolographFactory public factory;
    FeeRouter public feeRouterBase;
    FeeRouter public feeRouterEth;
    StakingRewards public stakingRewards;

    MockLZEndpoint public lzEndpointBase;
    MockLZEndpoint public lzEndpointEth;
    MockWETH public weth;
    MockHLG public hlg;
    MockSwapRouter public swapRouter;
    MockAirlock public airlock;

    // Doppler mock factories
    ITokenFactory public tokenFactory;
    IGovernanceFactory public governanceFactory;
    IPoolInitializer public poolInitializer;
    ILiquidityMigrator public liquidityMigrator;

    /* -------------------------------------------------------------------------- */
    /*                                Test Actors                                 */
    /* -------------------------------------------------------------------------- */

    address public owner = address(0x1);
    address public keeper = address(0x2);
    address public treasury = address(0x3);
    address public user = address(0x4);
    address public staker = address(0x5);

    /* -------------------------------------------------------------------------- */
    /*                                 Constants                                  */
    /* -------------------------------------------------------------------------- */

    uint32 constant BASE_EID = 30184;
    uint32 constant ETH_EID = 30101;
    uint256 constant LAUNCH_FEE = 0.005 ether;
    uint256 constant HOLO_FEE_BPS = 150; // 1.5%

    /* -------------------------------------------------------------------------- */
    /*                                   Events                                   */
    /* -------------------------------------------------------------------------- */

    event TokenLaunched(address indexed asset, bytes32 salt);
    event SlicePulled(address indexed airlock, address indexed token, uint256 holoAmt, uint256 treasuryAmt);
    event TokenBridged(address indexed token, uint256 amount, uint64 nonce);
    event Swapped(uint256 ethIn, uint256 hlgOut);
    event Burned(uint256 hlgAmt);
    event RewardsSent(uint256 hlgAmt);

    /* -------------------------------------------------------------------------- */
    /*                                   Setup                                    */
    /* -------------------------------------------------------------------------- */

    function setUp() public {
        vm.startPrank(owner);

        // Deploy core infrastructure
        _deployInfrastructure();

        // Deploy protocol contracts
        _deployProtocolContracts();

        // Configure cross-chain communication
        _configureCrossChain();

        // Setup roles and permissions
        _setupRoles();

        // Fund test accounts
        _fundAccounts();

        vm.stopPrank();
    }

    function _deployInfrastructure() internal {
        // LayerZero endpoints
        lzEndpointBase = new MockLZEndpoint();
        lzEndpointEth = new MockLZEndpoint();

        // DeFi infrastructure (Ethereum)
        weth = new MockWETH();
        hlg = new MockHLG();
        swapRouter = new MockSwapRouter();

        // Doppler infrastructure
        airlock = new MockAirlock();

        // Doppler mock factories
        tokenFactory = ITokenFactory(address(new MockTokenFactory()));
        governanceFactory = IGovernanceFactory(address(new MockGovernanceFactory()));
        poolInitializer = IPoolInitializer(address(new MockPoolInitializer()));
        liquidityMigrator = ILiquidityMigrator(address(new MockLiquidityMigrator()));
    }

    function _deployProtocolContracts() internal {
        // Deploy StakingRewards (Ethereum)
        stakingRewards = new StakingRewards(address(hlg), owner);

        // Deploy FeeRouter on Base
        feeRouterBase = new FeeRouter(
            address(lzEndpointBase),
            ETH_EID, // remote EID (Ethereum)
            address(0), // no staking on Base
            address(0), // no HLG on Base
            address(0), // no WETH on Base
            address(0), // no swap router on Base
            treasury
        );

        // Deploy FeeRouter on Ethereum
        feeRouterEth = new FeeRouter(
            address(lzEndpointEth),
            BASE_EID, // remote EID (Base)
            address(stakingRewards),
            address(hlg),
            address(weth),
            address(swapRouter),
            treasury
        );

        // Deploy HolographFactory (Base)
        factory = new HolographFactory(address(lzEndpointBase), address(airlock), address(feeRouterBase));
    }

    function _configureCrossChain() internal {
        // Set trusted remotes for cross-chain communication
        bytes32 baseRouterBytes32 = bytes32(uint256(uint160(address(feeRouterBase))));
        bytes32 ethRouterBytes32 = bytes32(uint256(uint160(address(feeRouterEth))));

        feeRouterBase.setTrustedRemote(ETH_EID, ethRouterBytes32);
        feeRouterEth.setTrustedRemote(BASE_EID, baseRouterBytes32);

        // Configure mock endpoints for cross-chain simulation
        lzEndpointBase.setCrossChainTarget(address(feeRouterEth));
        lzEndpointEth.setCrossChainTarget(address(feeRouterBase));
    }

    function _setupRoles() internal {
        // Grant keeper roles
        feeRouterBase.grantRole(feeRouterBase.KEEPER_ROLE(), keeper);
        feeRouterEth.grantRole(feeRouterEth.KEEPER_ROLE(), keeper);

        // Set StakingRewards fee router
        stakingRewards.setFeeRouter(address(feeRouterEth));
        stakingRewards.unpause(); // Enable staking
    }

    function _fundAccounts() internal {
        // Fund user for token launches
        vm.deal(user, 10 ether);

        // Fund staker with HLG tokens
        hlg.mint(staker, 1000e18);

        // Setup swap router to return HLG for any swap
        hlg.mint(address(swapRouter), 10000e18);
        swapRouter.setOutputToken(address(hlg));
        swapRouter.setExchangeRate(1000); // 1 ETH = 1000 HLG
    }

    /* -------------------------------------------------------------------------- */
    /*                              Integration Tests                             */
    /* -------------------------------------------------------------------------- */

    /**
     * @notice Test complete end-to-end flow: Launch → Fee → Bridge → Swap → Distribute
     * @dev This is the core integration test showing the full system working together
     */
    function testCompleteIntegrationFlow() public {
        console.log("=== Starting Complete Integration Flow Test ===");

        // STEP 1: User launches a token
        console.log("Step 1: Token Launch");
        _simulateTokenLaunch();

        // STEP 2: Keeper pulls fees from Airlock
        console.log("Step 2: Fee Collection from Airlock");
        _simulateAirlockFeeCollection();

        // STEP 3: Keeper bridges fees to Ethereum
        console.log("Step 3: Cross-Chain Bridge");
        _simulateCrossChainBridge();

        // STEP 4: Fees are swapped and distributed on Ethereum
        console.log("Step 4: Swap and Distribution");
        _verifyEthereumDistribution();

        // STEP 5: User stakes and earns rewards
        console.log("Step 5: Staking Rewards");
        _simulateStakingRewards();

        console.log("=== Integration Flow Test Complete ===");
    }

    function _simulateTokenLaunch() internal {
        uint256 launchFee = LAUNCH_FEE;
        uint256 expectedHolo = (launchFee * HOLO_FEE_BPS) / 10_000; // 1.5%
        uint256 expectedTreasury = launchFee - expectedHolo; // 98.5%

        CreateParams memory params = CreateParams({
            initialSupply: 1000000e18,
            numTokensToSell: 500000e18, // 50% of supply for sale
            numeraire: address(0), // ETH
            tokenFactory: tokenFactory,
            tokenFactoryData: abi.encode("Test Token", "TEST"),
            governanceFactory: governanceFactory,
            governanceFactoryData: abi.encode(""),
            poolInitializer: poolInitializer,
            poolInitializerData: abi.encode(""),
            liquidityMigrator: liquidityMigrator,
            liquidityMigratorData: abi.encode(""),
            integrator: address(0), // Will be overridden by factory
            salt: bytes32(uint256(1))
        });

        vm.expectEmit(true, true, false, true);
        emit SlicePulled(address(0), address(0), expectedHolo, expectedTreasury);

        vm.prank(user);
        address newToken = factory.createToken{value: launchFee}(params);

        // Verify fee slicing worked correctly
        assertEq(treasury.balance, expectedTreasury, "Treasury should receive 98.5%");
        assertEq(address(feeRouterBase).balance, expectedHolo, "FeeRouter should keep 1.5%");

        console.log("Token launched:", newToken);
        console.log("Treasury received:", expectedTreasury);
        console.log("FeeRouter kept for bridging:", expectedHolo);
    }

    function _simulateAirlockFeeCollection() internal {
        // Simulate additional fees accumulated in Airlock
        uint256 airlockFees = 0.01 ether;
        vm.deal(address(airlock), airlockFees);
        airlock.setCollectableAmount(address(0), airlockFees);

        uint256 routerBalanceBefore = address(feeRouterBase).balance;

        vm.prank(keeper);
        feeRouterBase.pullAndSlice(address(airlock), address(0), uint128(airlockFees));

        uint256 expectedHolo = (airlockFees * HOLO_FEE_BPS) / 10_000;
        uint256 routerBalanceAfter = address(feeRouterBase).balance;

        assertEq(routerBalanceAfter - routerBalanceBefore, expectedHolo, "Additional fees should be sliced correctly");

        console.log("Airlock fees collected:", expectedHolo);
    }

    function _simulateCrossChainBridge() internal {
        uint256 routerBalance = address(feeRouterBase).balance;
        console.log("Bridging amount:", routerBalance);

        // Ensure balance is above minimum bridge value
        assertGe(routerBalance, 0.01 ether, "Should have enough to bridge");

        vm.expectEmit(true, false, false, true);
        emit TokenBridged(address(0), routerBalance, 1);

        vm.prank(keeper);
        feeRouterBase.bridge(200_000, 0); // No slippage protection for test

        // Verify message was sent via LayerZero
        assertTrue(lzEndpointBase.sendCalled(), "LayerZero send should be called");
        assertEq(lzEndpointBase.lastValue(), routerBalance, "Full balance should be bridged");

        console.log("Bridge message sent with value:", routerBalance);
    }

    function _verifyEthereumDistribution() internal {
        // The mock endpoint should have triggered the receive on Ethereum side
        // Check if HLG was distributed correctly

        uint256 stakingBalance = hlg.balanceOf(address(stakingRewards));
        uint256 burnedAmount = hlg.totalSupply() - hlg.balanceOf(address(swapRouter)) - stakingBalance;

        console.log("HLG sent to staking:", stakingBalance);
        console.log("HLG burned:", burnedAmount);

        // Verify 50/50 split (allowing for small rounding differences)
        if (stakingBalance > 0) {
            uint256 total = stakingBalance + burnedAmount;
            assertApproxEqRel(stakingBalance, total / 2, 0.01e18, "Should be approximately 50% to staking");
            assertApproxEqRel(burnedAmount, total / 2, 0.01e18, "Should be approximately 50% burned");
        }
    }

    function _simulateStakingRewards() internal {
        uint256 stakeAmount = 100e18;

        // User stakes HLG
        vm.startPrank(staker);
        hlg.approve(address(stakingRewards), stakeAmount);
        stakingRewards.stake(stakeAmount);
        vm.stopPrank();

        // Check staking worked
        assertEq(stakingRewards.balanceOf(staker), stakeAmount, "Stake amount should be recorded");

        // Simulate time passing to allow cooldown
        vm.warp(block.timestamp + 8 days);

        // Check if rewards are available
        uint256 earned = stakingRewards.earned(staker);
        console.log("Rewards earned by staker:", earned);

        if (earned > 0) {
            vm.prank(staker);
            stakingRewards.claim();
            console.log("Rewards claimed successfully");
        }
    }

    /* -------------------------------------------------------------------------- */
    /*                             Edge Case Tests                                */
    /* -------------------------------------------------------------------------- */

    function testDustAmountsDontBridge() public {
        // Send a very small amount (below MIN_BRIDGE_VALUE)
        uint256 dustAmount = 0.005 ether;
        vm.deal(address(feeRouterBase), dustAmount);

        vm.prank(keeper);
        feeRouterBase.bridge(200_000, 0);

        // Should not have called LayerZero
        assertFalse(lzEndpointBase.sendCalled(), "Dust amounts should not trigger bridge");
        assertEq(address(feeRouterBase).balance, dustAmount, "Dust should remain in contract");
    }

    function testMultipleTokenLaunches() public {
        uint256 numLaunches = 5;
        uint256 totalFees = 0;

        for (uint256 i = 0; i < numLaunches; i++) {
            CreateParams memory params = CreateParams({
                initialSupply: 1000000e18,
                numTokensToSell: 500000e18,
                numeraire: address(0),
                tokenFactory: tokenFactory,
                tokenFactoryData: abi.encode(string(abi.encodePacked("Token ", i)), string(abi.encodePacked("TK", i))),
                governanceFactory: governanceFactory,
                governanceFactoryData: abi.encode(""),
                poolInitializer: poolInitializer,
                poolInitializerData: abi.encode(""),
                liquidityMigrator: liquidityMigrator,
                liquidityMigratorData: abi.encode(""),
                integrator: address(0),
                salt: bytes32(uint256(i + 100))
            });

            vm.prank(user);
            factory.createToken{value: LAUNCH_FEE}(params);

            totalFees += LAUNCH_FEE;
        }

        uint256 expectedTotalHolo = (totalFees * HOLO_FEE_BPS) / 10_000;
        uint256 expectedTotalTreasury = totalFees - expectedTotalHolo;

        assertEq(treasury.balance, expectedTotalTreasury, "Treasury should receive 98.5% of all fees");
        assertEq(address(feeRouterBase).balance, expectedTotalHolo, "FeeRouter should keep 1.5% of all fees");

        console.log("Multiple launches completed - Total fees processed:", totalFees);
    }

    function testERC20TokenFeeFlow() public {
        MockERC20 token = new MockERC20("Fee Token", "FEE");
        uint256 tokenAmount = 1000e18;

        // Setup: mint tokens and fund user
        token.mint(user, tokenAmount);

        vm.startPrank(user);
        token.approve(address(feeRouterBase), tokenAmount);
        feeRouterBase.routeFeeToken(address(token), tokenAmount);
        vm.stopPrank();

        uint256 expectedHolo = (tokenAmount * HOLO_FEE_BPS) / 10_000;
        uint256 expectedTreasury = tokenAmount - expectedHolo;

        assertEq(token.balanceOf(treasury), expectedTreasury, "Treasury should receive 98.5% of tokens");
        assertEq(token.balanceOf(address(feeRouterBase)), expectedHolo, "FeeRouter should keep 1.5% of tokens");

        // Test bridging ERC-20 tokens
        vm.prank(keeper);
        feeRouterBase.bridgeToken(address(token), 200_000, 0);

        assertTrue(lzEndpointBase.sendCalled(), "Token bridge should trigger LayerZero");
        console.log("ERC-20 token fee flow completed successfully");
    }

    /* -------------------------------------------------------------------------- */
    /*                              Failure Cases                                 */
    /* -------------------------------------------------------------------------- */

    function testUnauthorizedKeeperActions() public {
        // Non-keeper trying to pull fees
        vm.expectRevert();
        vm.prank(user);
        feeRouterBase.pullAndSlice(address(airlock), address(0), 0.1 ether);

        // Non-keeper trying to bridge
        vm.expectRevert();
        vm.prank(user);
        feeRouterBase.bridge(200_000, 0);

        // Non-owner trying to pause
        vm.expectRevert();
        vm.prank(user);
        feeRouterBase.pause();

        console.log("Authorization checks passed");
    }

    function testPausedOperations() public {
        // Pause the contract
        vm.prank(owner);
        feeRouterBase.pause();

        // Operations should fail when paused
        vm.expectRevert();
        vm.prank(user);
        feeRouterBase.receiveFee{value: 1 ether}();

        vm.expectRevert();
        vm.prank(user);
        factory.createToken{value: LAUNCH_FEE}(
            CreateParams({
                initialSupply: 1000000e18,
                numTokensToSell: 500000e18,
                numeraire: address(0),
                tokenFactory: tokenFactory,
                tokenFactoryData: abi.encode("Test", "TEST"),
                governanceFactory: governanceFactory,
                governanceFactoryData: abi.encode(""),
                poolInitializer: poolInitializer,
                poolInitializerData: abi.encode(""),
                liquidityMigrator: liquidityMigrator,
                liquidityMigratorData: abi.encode(""),
                integrator: address(0),
                salt: bytes32(uint256(999))
            })
        );

        console.log("Pause functionality working correctly");
    }
}
